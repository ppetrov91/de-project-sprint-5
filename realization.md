## 1. Пояснения к общей работе pipeline.

  1. Для загрузки данных из внешних систем используются:
       - load_bonus_system_data.py для загрузки данных из системы учёта бонусов.
       - load_delivery_system_data.py для загрузки данных из системы учёта доставок.
       - load_order_system_data.py для загрузки данных из системы учёта заказов.
       
     Данные DAG работают независимо друг от друга, если какая-либо из систем будет недоступна, то это не помешает забирать данные из других систем.

     
  2. Для заполнения слоя DDS используется fill_dds_data_dag.py. Он работает независимо от DAG для загрузки данных из staging.
  
     Если при загрузке данных из внешних источников возникла ошибка, то и слой DDS обновляться не будет, т.е, данные не будут испорчены.

  3. Для заполнения слоя CDM используется fill_cdm_data_dag.py. Он работает независимо от других DAG.
  
     Если в работе предыдущих DAG возникнут ошибки, то слой CDM обновляться не будет, т.е, данные не будут испорчены.

## 2. Пояснения к заполнению слоя stg.

  1. Сначала выполняется запрос к таблице stg.srv_wf_settings и выбирается последнее загруженное значение (идентификатор или timestamp).
  
  2. Основная работа выполняется в функции load_data класса LoadDataFromExtSystem файла load_data_from_ext_system.py.
  
     Сначала с помощью метода _get_last_loaded_value() выбирается последнее загруженное значение для той или иной сущности.
     
     Затем методом _get_data_from_ext_system() выкачиваются данные из внешней системы. 
     
     Стоит отметить, что этот метод переопределяется классами-наследниками, поскольку для забора данных из той или иной системы своя логика.
     
     После этого данные записываются в БД с помощью метода _write_data().

     В нём вызываются методы _write_data_to_db() и _update_srv_settings() длязаписи данных в БД и обновления stg.srv_wf_settings соответственно.
     
     Классы-наследники переопределяют _write_data_to_db() поскольку для записи тех или иных данных в БД нужен свой набор действий.
     
## 3. Пояснения к заполнению слоя dds.

  1. Для заполнения слоя dds используются хранимые процедуры на стороне СУБД PostgreSQL, раз все данные находятся внутри целевой СУБД, то удобно использовать её возможности для обработки данных. DAG здесь просто вызывает соответствующую хранимую процедуру.
  
  2. Здесь также используется таблица srv_wf_settings, но уже в схеме dds.
  
     В качестве последнего обработанного значения используется отметка времени, поскольку она монотонно возрастает, это позволяет не пропустить те или иные данные из stg слоя.
     
     Затем выбираются данные, у которых временная метка обновления больше или равна последней обработанной метке. 
     
     Среди этих данных выбирается максимальная отметка времени, которая и будет записана в dds.srv_wf_settings.

  3. Добавлены измерения dm_couriers, dm_addresses, dm_deliveries.

     Для dm_couriers и dm_addresses используется SCD1.

  4. courier_id больше подходит доставке, а не заказу, поэтому courier_id находится в dm_deliveries, а не dm_orders.

  5. В dm_deliveries и в fct_order_deliveries есть поле delivery_date типа timestamp. Это нужно для ускорения построения витрин данных.

     Использование идентификатора в dm_timestamps не даст преимущества, поскольку будет лишний JOIN.

     Поскольку в фактах будет много данных, то нужен способ быстрого их извлечения.

  6. Порядок обработки таблиц следующий:
  	- Параллельно обрабатываются таблицы dm_addresses, dm_couriers, dm_restaurants, dm_timestamps, dm_users.
  	- Затем последовательно обрабатываются dm_products, dm_orders, dm_deliveries.
  	- Затем параллельно обраюатываются факты fct_order_deliveries и fct_product_sales.
      
  7. За наполнение таблиц схемы dds отвечают следующие хранимые процедуры:
    
    	- fill_dm_users() -> dm_users.
    	- fill_dm_couriers() -> dm_couriers.
    	- fill_dm_restaurants() -> dm_restaurants.
    	- fill_dm_timestamps() -> dm_timestamps.
    	- fill_dm_users() -> dm_users.
    	- fill_dm_products() -> dm_products.
    	- fill_dm_orders() -> dm_orders.
    	- fill_dm_deliveries() -> dm_deliveries.
    	- fill_fct_order_deliveries() -> fct_order_deliveries.
    	- fill_fct_product_sales() -> fct_product_sales.

## 4. Пояснения к заполнению слоя cdm.

   1. Для заполнения слоя cdm используются хранимые процедуры на стороне СУБД PostgreSQL, раз все данные находятся внутри целевой СУБД, то удобно использовать её возможности для обработки данных. DAG здесь просто вызывает соответствующую хранимую процедуру.
   
   2. Здесь также используется таблица srv_wf_settings, но уже в схеме cdm.
  
     В качестве последнего обработанного значения используется отметка времени, поскольку она монотонно возрастает, это позволяет не пропустить те или иные данные из stg слоя.
     
     Затем выбираются данные, у которых временная метка обновления больше или равна последней обработанной метке. 
     
     Среди этих данных выбирается максимальная отметка времени, которая и будет записана в cdm.srv_wf_settings.
     
   3. Витрины данных заполняются независимо друг от друга.
   
   4. За наполнение таблиц схемы cdm отвечают следующие хранимые процедуры:
   
      	- fill_dm_settlement_report() -> dm_settlement_report.
      	- fill_dm_courier_ledger() -> dm_courier_ledger.
